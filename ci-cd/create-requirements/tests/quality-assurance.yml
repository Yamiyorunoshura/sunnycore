# Create Requirements 品質保證測試
# 此配置進行全面的需求文檔品質評估，確保專業標準

description: "Create Requirements Quality Assurance Tests"

providers:
  - claude-sonnet

prompts:
  - file: prompts/create-requirements-full.md

tests:
  # 整體需求文檔品質評估
  - description: "整體需求文檔品質評估"
    vars:
      user_input: "開發一個企業級人力資源管理系統(HRMS)，涵蓋員工資訊管理、薪酬管理、績效評估、培訓管理、招聘管理、考勤管理和報表分析等核心模組，需要支援多組織架構、權限控制、工作流程和系統整合。"
    options:
      provider: claude-sonnet
      runs: 2
    assert:
      - type: llm-rubric
        value: |
          專業需求分析師評估標準（滿分100分）：
          
          【需求完整性 - 25分】
          - 功能需求覆蓋是否全面（10分）
          - 非功能需求是否充分考慮（10分）
          - 邊界條件和異常處理是否包含（5分）
          
          【需求品質 - 25分】
          - 需求描述是否明確無歧義（10分）
          - 驗收標準是否具體可測試（10分）
          - 優先級設定是否合理（5分）
          
          【專業水準 - 25分】
          - 使用標準化的需求工程術語（10分）
          - 需求ID和分類規範性（8分）
          - 整體結構邏輯清晰（7分）
          
          【業務理解 - 25分】
          - 對HRMS領域理解深度（15分）
          - 企業級系統考量完整性（10分）
          
          總分需達到85分以上視為優秀品質。
        description: "專業需求分析師品質評估"
      - type: custom-function
        value: |
          function(output) {
            const yaml = require('js-yaml');
            try {
              const parsed = yaml.load(output);
              let totalScore = 0;
              
              // 1. 需求完整性評分 (25分)
              let completenessScore = 0;
              const funcReqs = parsed.functional_requirements || [];
              const nonFuncReqs = parsed.non_functional_requirements || [];
              
              // 功能需求覆蓋度
              const expectedModules = ['員工', '薪酬', '績效', '培訓', '招聘', '考勤', '報表'];
              const modulesCovered = expectedModules.filter(module => 
                output.includes(module)
              ).length;
              completenessScore += (modulesCovered / expectedModules.length) * 10;
              
              // 非功能需求類型多樣性
              const nfrTypes = [...new Set(nonFuncReqs.map(req => req.type))];
              completenessScore += Math.min(nfrTypes.length * 2, 10);
              
              // 異常處理考量
              const hasExceptionHandling = /異常|錯誤|失敗|容錯/.test(output);
              if (hasExceptionHandling) completenessScore += 5;
              
              // 2. 需求品質評分 (25分)
              let qualityScore = 0;
              
              // 需求描述明確性
              const avgDescLength = funcReqs.reduce((acc, req) => 
                acc + (req.description ? req.description.length : 0), 0) / funcReqs.length;
              qualityScore += avgDescLength > 50 ? 10 : avgDescLength > 20 ? 7 : 3;
              
              // 驗收標準具體性
              const avgAcceptanceCount = funcReqs.reduce((acc, req) => 
                acc + (req.acceptance_criteria ? req.acceptance_criteria.length : 0), 0) / funcReqs.length;
              qualityScore += avgAcceptanceCount >= 3 ? 10 : avgAcceptanceCount >= 2 ? 7 : avgAcceptanceCount >= 1 ? 4 : 0;
              
              // 優先級分布合理性
              const priorities = funcReqs.map(req => req.priority).filter(p => p);
              const hasVariedPriorities = new Set(priorities).size >= 2;
              qualityScore += hasVariedPriorities ? 5 : 2;
              
              // 3. 專業水準評分 (25分)
              let professionalScore = 0;
              
              // 標準化術語使用
              const professionalTerms = ['需求', '功能', '非功能', '驗收標準', 'stakeholder', 'user story'];
              const termsUsed = professionalTerms.filter(term => output.includes(term)).length;
              professionalScore += (termsUsed / professionalTerms.length) * 10;
              
              // ID規範性
              const funcIdPattern = /F-\d{3}/g;
              const nfrIdPattern = /NFR-[A-Z]-\d{3}/g;
              const funcIdCount = (output.match(funcIdPattern) || []).length;
              const nfrIdCount = (output.match(nfrIdPattern) || []).length;
              const idCompliance = (funcIdCount + nfrIdCount) / (funcReqs.length + nonFuncReqs.length);
              professionalScore += idCompliance >= 0.9 ? 8 : idCompliance >= 0.7 ? 6 : 3;
              
              // 結構邏輯清晰性
              const hasProjectInfo = parsed.project_info && parsed.project_info.name;
              const hasObjectives = parsed.project_info && parsed.project_info.objectives;
              professionalScore += hasProjectInfo ? 4 : 0;
              professionalScore += hasObjectives ? 3 : 0;
              
              // 4. 業務理解評分 (25分)
              let businessScore = 0;
              
              // HRMS領域理解
              const hrmsKeywords = ['人力資源', '員工', '組織', '權限', '工作流', '多租戶', '整合'];
              const keywordsFound = hrmsKeywords.filter(keyword => output.includes(keyword)).length;
              businessScore += (keywordsFound / hrmsKeywords.length) * 15;
              
              // 企業級考量
              const enterpriseFeatures = ['權限控制', '多組織', '工作流程', '系統整合', '安全', '性能'];
              const enterpriseFeaturesFound = enterpriseFeatures.filter(feature => output.includes(feature)).length;
              businessScore += (enterpriseFeaturesFound / enterpriseFeatures.length) * 10;
              
              totalScore = completenessScore + qualityScore + professionalScore + businessScore;
              
              return {
                pass: totalScore >= 85,
                score: totalScore / 100,
                reason: `品質評估總分: ${totalScore.toFixed(1)}/100 (完整性:${completenessScore.toFixed(1)}, 品質:${qualityScore.toFixed(1)}, 專業:${professionalScore.toFixed(1)}, 業務:${businessScore.toFixed(1)})`
              };
            } catch (error) {
              return { pass: false, score: 0, reason: `品質評估失敗: ${error.message}` };
            }
          }
        description: "綜合品質評估算法"

  # 需求可追溯性測試
  - description: "需求可追溯性和一致性測試"
    vars:
      user_input: "建立一個電子商務平台，支援B2B和B2C兩種模式，包含商品管理、庫存控制、訂單處理、支付系統、物流管理、客戶服務和數據分析功能。"
    options:
      provider: claude-sonnet
      runs: 2
    assert:
      - type: custom-function
        value: |
          function(output) {
            const yaml = require('js-yaml');
            try {
              const parsed = yaml.load(output);
              let traceabilityScore = 0;
              
              // 1. 需求ID一致性檢查
              const funcReqs = parsed.functional_requirements || [];
              const nonFuncReqs = parsed.non_functional_requirements || [];
              
              const funcIds = funcReqs.map(req => req.id).filter(id => id);
              const nfrIds = nonFuncReqs.map(req => req.id).filter(id => id);
              const allIds = [...funcIds, ...nfrIds];
              
              // 檢查ID唯一性
              const uniqueIds = new Set(allIds);
              const idUniqueness = allIds.length > 0 ? uniqueIds.size / allIds.length : 0;
              traceabilityScore += idUniqueness >= 1.0 ? 20 : idUniqueness >= 0.95 ? 15 : 10;
              
              // 2. 需求依賴關係檢查
              const hasDependencies = funcReqs.some(req => req.dependencies && req.dependencies.length > 0);
              traceabilityScore += hasDependencies ? 15 : 5;
              
              // 3. 用戶故事與需求對應
              const hasUserStories = funcReqs.filter(req => req.user_story && req.user_story.includes('As a')).length;
              const userStoryRatio = funcReqs.length > 0 ? hasUserStories / funcReqs.length : 0;
              traceabilityScore += userStoryRatio >= 0.8 ? 20 : userStoryRatio >= 0.5 ? 15 : userStoryRatio >= 0.3 ? 10 : 5;
              
              // 4. 驗收標準可測試性
              const testableAcceptance = funcReqs.filter(req => {
                return req.acceptance_criteria && req.acceptance_criteria.some(criteria => 
                  /應該|必須|能夠|可以|when|given|then/i.test(criteria)
                );
              }).length;
              const testabilityRatio = funcReqs.length > 0 ? testableAcceptance / funcReqs.length : 0;
              traceabilityScore += testabilityRatio >= 0.8 ? 25 : testabilityRatio >= 0.6 ? 20 : testabilityRatio >= 0.4 ? 15 : 10;
              
              // 5. 非功能需求量化程度
              const quantifiedNFRs = nonFuncReqs.filter(req => 
                req.target_value && /\d+/.test(req.target_value)
              ).length;
              const quantificationRatio = nonFuncReqs.length > 0 ? quantifiedNFRs / nonFuncReqs.length : 0;
              traceabilityScore += quantificationRatio >= 0.7 ? 20 : quantificationRatio >= 0.5 ? 15 : quantificationRatio >= 0.3 ? 10 : 5;
              
              return {
                pass: traceabilityScore >= 80,
                score: traceabilityScore / 100,
                reason: `可追溯性評分: ${traceabilityScore}/100 (ID唯一性: ${(idUniqueness*100).toFixed(1)}%, 用戶故事覆蓋: ${(userStoryRatio*100).toFixed(1)}%, 可測試性: ${(testabilityRatio*100).toFixed(1)}%)`
              };
            } catch (error) {
              return { pass: false, score: 0, reason: `可追溯性檢查失敗: ${error.message}` };
            }
          }
        description: "需求可追溯性檢查"

  # 專業術語和標準合規性測試
  - description: "專業術語和標準合規性測試"
    vars:
      user_input: "設計一個金融交易系統，需要符合相關監管要求，支援多種金融商品交易、風險管理、合規報告、用戶認證和資料安全等功能。"
    options:
      provider: claude-sonnet
      runs: 2
    assert:
      - type: llm-rubric
        value: |
          專業標準合規性評估：
          1. 使用IEEE 830標準的需求規格書結構
          2. 採用標準的需求工程術語
          3. 金融領域專業術語使用正確
          4. 合規性考量充分且具體
          5. 風險管理需求專業完整
        description: "專業標準合規性評估"
      - type: custom-function
        value: |
          function(output) {
            let complianceScore = 0;
            
            // 1. IEEE 830標準結構要素
            const ieee830Elements = [
              'project_info', 'functional_requirements', 'non_functional_requirements',
              'description', 'acceptance_criteria', 'priority'
            ];
            const ieee830Coverage = ieee830Elements.filter(element => 
              output.includes(element)
            ).length;
            complianceScore += (ieee830Coverage / ieee830Elements.length) * 20;
            
            // 2. 需求工程標準術語
            const reTerms = [
              '功能需求', '非功能需求', '驗收標準', '優先級', '利害關係人',
              'user story', '測試方法', '風險評估'
            ];
            const reTermsCovered = reTerms.filter(term => output.includes(term)).length;
            complianceScore += (reTermsCovered / reTerms.length) * 20;
            
            // 3. 金融領域專業術語
            const financeTerms = [
              '交易', '風險管理', '合規', '認證', '資料安全', '監管',
              '金融商品', '報告'
            ];
            const financeTermsCovered = financeTerms.filter(term => output.includes(term)).length;
            complianceScore += (financeTermsCovered / financeTerms.length) * 20;
            
            // 4. 合規性要求專業性
            const complianceKeywords = ['法規', '監管', '合規', '稽核', '風控'];
            const complianceKeywordsCovered = complianceKeywords.filter(keyword => 
              output.includes(keyword)
            ).length;
            complianceScore += (complianceKeywordsCovered / complianceKeywords.length) * 20;
            
            // 5. 安全性考量專業程度
            const securityAspects = ['認證', '授權', '加密', '審計', '監控'];
            const securityAspectsCovered = securityAspects.filter(aspect => 
              output.includes(aspect)
            ).length;
            complianceScore += (securityAspectsCovered / securityAspects.length) * 20;
            
            return {
              pass: complianceScore >= 80,
              score: complianceScore / 100,
              reason: `標準合規性評分: ${complianceScore.toFixed(1)}/100 (IEEE830: ${(ieee830Coverage/ieee830Elements.length*100).toFixed(1)}%, 金融術語: ${(financeTermsCovered/financeTerms.length*100).toFixed(1)}%)`
            };
          }
        description: "標準合規性檢查"

  # 實際應用價值評估
  - description: "需求文檔實際應用價值評估"
    vars:
      user_input: "開發一個智慧製造執行系統(MES)，整合生產計劃、車間排程、設備監控、品質管理、物料追蹤和數據分析等功能，支援工業4.0和物聯網技術。"
    options:
      provider: claude-sonnet
      runs: 2
    assert:
      - type: llm-rubric
        value: |
          實際應用價值評估標準：
          1. 需求是否可直接指導系統設計和開發（25分）
          2. 驗收標準是否足夠具體，可直接用於測試（25分）
          3. 非功能需求是否提供明確的技術指標（20分）
          4. 需求是否考慮了實際業務場景和約束（20分）
          5. 整體需求是否具有可實施性和可維護性（10分）
          
          評分達到80分以上表示具有良好的實際應用價值。
        description: "實際應用價值評估"
      - type: custom-function
        value: |
          function(output) {
            const yaml = require('js-yaml');
            try {
              const parsed = yaml.load(output);
              let practicalValueScore = 0;
              
              const funcReqs = parsed.functional_requirements || [];
              const nonFuncReqs = parsed.non_functional_requirements || [];
              
              // 1. 設計指導性 (25分)
              const hasDetailedDescription = funcReqs.filter(req => 
                req.description && req.description.length >= 50
              ).length;
              const descriptionRatio = funcReqs.length > 0 ? hasDetailedDescription / funcReqs.length : 0;
              practicalValueScore += descriptionRatio >= 0.8 ? 25 : descriptionRatio >= 0.6 ? 20 : descriptionRatio >= 0.4 ? 15 : 10;
              
              // 2. 測試可執行性 (25分)
              const executableAcceptance = funcReqs.filter(req => {
                if (!req.acceptance_criteria) return false;
                return req.acceptance_criteria.some(criteria => 
                  /驗證|測試|檢查|確認|when.*then|given.*when|應該.*結果/i.test(criteria)
                );
              }).length;
              const testabilityRatio = funcReqs.length > 0 ? executableAcceptance / funcReqs.length : 0;
              practicalValueScore += testabilityRatio >= 0.8 ? 25 : testabilityRatio >= 0.6 ? 20 : testabilityRatio >= 0.4 ? 15 : 10;
              
              // 3. 技術指標明確性 (20分)
              const quantifiedNFRs = nonFuncReqs.filter(req => 
                (req.target_value && /\d+/.test(req.target_value)) ||
                (req.metric && req.metric.length > 5)
              ).length;
              const quantificationRatio = nonFuncReqs.length > 0 ? quantifiedNFRs / nonFuncReqs.length : 0;
              practicalValueScore += quantificationRatio >= 0.8 ? 20 : quantificationRatio >= 0.6 ? 16 : quantificationRatio >= 0.4 ? 12 : 8;
              
              // 4. 業務場景考量 (20分)
              const businessScenarioIndicators = [
                '製造', '生產', '車間', '設備', '品質', '物料', '工業4.0', '物聯網'
              ];
              const businessContextCovered = businessScenarioIndicators.filter(indicator => 
                output.includes(indicator)
              ).length;
              practicalValueScore += (businessContextCovered / businessScenarioIndicators.length) * 20;
              
              // 5. 可實施性和可維護性 (10分)
              const implementabilityFactors = ['模組化', '可擴展', '可維護', '整合', '配置'];
              const implementabilityFactorsCovered = implementabilityFactors.filter(factor => 
                output.includes(factor)
              ).length;
              practicalValueScore += (implementabilityFactorsCovered / implementabilityFactors.length) * 10;
              
              return {
                pass: practicalValueScore >= 80,
                score: practicalValueScore / 100,
                reason: `實際應用價值評分: ${practicalValueScore.toFixed(1)}/100 (可測試性: ${(testabilityRatio*100).toFixed(1)}%, 技術指標: ${(quantificationRatio*100).toFixed(1)}%, 業務場景: ${(businessContextCovered/businessScenarioIndicators.length*100).toFixed(1)}%)`
              };
            } catch (error) {
              return { pass: false, score: 0, reason: `實際應用價值評估失敗: ${error.message}` };
            }
          }
        description: "實際應用價值算法評估"
