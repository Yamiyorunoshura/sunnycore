<input>
  <context>
  1. 用戶提供的複雜任務描述和需求
  2. {project_root}/claude code/sunnycore/config.yaml - 可用的子智能體列表
  3. {project_root}/claude code/agents/ - 各專業領域子智能體的能力定義
  4. 當前項目的文檔結構和代碼庫狀態
  </context>
  <templates>
  1. 子智能體任務分配標準化模板
  2. 進度監控和報告模板
  3. 依賴關係分析模板
  4. 異常處理和恢復流程模板
  </templates>
  <subagent-list>
  - {project_root}/sunnycore/config.yaml
    - orchestrator-subagent-list
  </subagent-list>
</input>

<output>
1. 任務分解與依賴關係分析報告
2. 子智能體分配與協調計劃
3. 並行執行進度監控儀表板
4. 整合測試與質量保證報告
5. 最終交付成果與改進建議
</output>

<constraints, importance = "Critical">
- 必須識別並正確處理所有任務間的依賴關係
- 必須選擇最適合的子智能體進行任務分配
- 必須建立實時的進度監控和異常處理機制
- 必須確保並行執行不會產生資源衝突
- 必須維護完整的執行記錄和可追溯性
- 必須在所有關鍵節點實施質量檢查
- 若任何關鍵子任務失敗，必須啟動應急處理程序
</constraints>

<workflow, importance = "Critical">
  <stage id="1: 複雜任務解析與理解", level_of_think = "ultra think", read_token_budget = "200K", write_token_budget = "50K", cache_read_budget = "150K">
  - 使用 Sequential-thinking Tool 深度分析用戶提供的任務描述
  - 識別任務的核心業務目標、技術需求和約束條件
  - 分析任務的複雜度、預估工作量和時間範圍
  - 識別任務中的關鍵風險點和挑戰
  - 構建需求確認清單，確保對任務理解無誤
  - 識別模糊或缺失的需求細節
  - 向用戶提出精確的澄清問題
  
  <questions>
  - 這個任務的最終交付成果具體是什麼？
  - 是否有特定的技術棧、框架或工具限制？
  - 任務的優先級排序是什麼？
  - 是否存在必須遵循的品質標準或規範？
  - 有哪些外部依賴或第三方整合需求？
  </questions>
  
  <checks>
    - [ ] 任務的核心目標已明確識別
    - [ ] 所有技術需求和約束條件已記錄
    - [ ] 複雜度和工作量評估已完成
    - [ ] 關鍵風險點已識別並記錄
    - [ ] 需求澄清已完成（如有需要）
  </checks>
  </stage>

  <stage id="2: 智能任務分解與子任務定義", level_of_think = "ultra think", read_token_budget = "150K", write_token_budget = "80K", cache_read_budget = "100K">
  - 使用工作分解結構 (WBS) 方法論進行系統化分解
  - 確保每個子任務具有明確的輸入、處理過程和輸出
  - 每個子任務應具備獨立性，可由單一子智能體完成
  - 子任務的粒度適中：既不過於粗糙也不過於細碎
  - 檢查是否涵蓋了原始任務的所有需求
  - 驗證子任務間沒有功能重疊或遺漏
  - 確保每個子任務都有清楚的責任邊界
  
  <questions>
  - 這樣的任務分解是否涵蓋了所有的功能需求？
  - 每個子任務的邊界是否清晰，不會產生責任混淆？
  - 是否有任何子任務過於複雜，需要進一步分解？
  - 分解的粒度是否適合並行執行和進度監控？
  </questions>
  
  <checks>
    - [ ] 所有子任務已使用標準化格式定義
    - [ ] 每個子任務具有明確的輸入、處理、輸出規格
    - [ ] 任務分解完整性已驗證
    - [ ] 子任務獨立性已確認
    - [ ] 責任邊界清晰無重疊
  </checks>
  </stage>

  <stage id="3: 依賴關係深度分析與執行圖構建", level_of_think = "ultra think", read_token_budget = "120K", write_token_budget = "60K", cache_read_budget = "80K">
  - 分析數據流依賴：哪些子任務需要其他任務的輸出作為輸入
  - 分析技術依賴：基礎設施、API、資料庫schema等技術前置需求
  - 分析業務邏輯依賴：業務流程中的順序約束
  - 分析資源依賴：共享資源的互斥使用需求
  - 使用有向無環圖 (DAG) 表示任務執行順序
  - 標識關鍵路徑 (Critical Path) 和並行執行機會
  - 計算每個任務的最早開始時間和最晚完成時間
  - 最大化可並行執行的任務數量
  - 平衡工作負載分布
  - 考慮子智能體的專業能力限制
  
  <questions>
  - 是否所有的依賴關係都已被正確識別？
  - 關鍵路徑是否已被準確計算？
  - 並行執行計劃是否已最優化？
  - 是否考慮了資源衝突和瓶頸？
  </questions>
  
  <checks>
    - [ ] 所有依賴關係已識別並分類
    - [ ] 執行DAG已構建完成
    - [ ] 關鍵路徑已計算並標識
    - [ ] 並行執行機會已識別
    - [ ] 資源衝突已分析並解決
  </checks>
  </stage>

  <stage id="4: 智能子智能體選擇與能力匹配", level_of_think = "think harder", read_token_budget = "100K", write_token_budget = "40K", cache_read_budget = "60K">
  - 分析每個子任務所需的專業技能領域
  - 評估可用子智能體的專業能力和經驗等級
  - 計算任務-智能體的匹配度分數
  - 考慮工作負載平衡和專長互補
  - 關鍵路徑任務分配給最可靠的高級智能體
  - 複雜任務考慮智能體組合或主-副智能體模式
  - 確保每個智能體的工作負載合理平衡
  - 預留備用智能體處理失敗恢復情況
  
  <questions>
  - 每個子任務是否已分配給最適合的智能體？
  - 工作負載是否在各智能體間合理分布？
  - 是否有智能體被過度分配或利用不足？
  - 關鍵任務是否分配給了最可靠的智能體？
  </questions>
  
  <checks>
    - [ ] 每個子任務已分配給合適的智能體
    - [ ] 智能體能力與任務需求匹配度已驗證
    - [ ] 工作負載平衡已檢查並調整
    - [ ] 關鍵路徑任務已分配給最佳智能體
    - [ ] 備用方案已準備就緒
  </checks>
  </stage>

  <stage id="5: Todo List創建與任務狀態管理系統", level_of_think = "think", read_token_budget = "80K", write_token_budget = "60K", cache_read_budget = "40K">
  - 根據依賴關係和關鍵路徑動態調整優先級
  - 當高優先級任務完成時，自動激活其依賴任務
  - 監控延遲任務並調整後續任務的優先級
  
  <questions>
  - Todo List 是否涵蓋了所有已識別的子任務？
  - 每個任務的狀態定義是否清晰無歧義？
  - 優先級分配是否合理反映了任務的重要性？
  - 狀態更新機制是否能夠支持實時監控？
  </questions>
  
  <checks>
    - [ ] 完整的Todo List已使用TodoWrite創建
    - [ ] 所有子任務已包含必要的metadata
    - [ ] 狀態管理流程已定義並測試
    - [ ] 優先級和依賴關係已正確設置
    - [ ] 動態更新機制已建立
  </checks>
  </stage>

  <stage id="6: 並行智能體協調執行與實時監控", level_of_think = "think harder", read_token_budget = "300K", write_token_budget = "100K", cache_read_budget = "200K">
  - 同時調用多個子智能體
  - 根據依賴關係圖按批次啟動任務執行
  - 實施智能體間的標準化溝通協議
  - 建立統一的進度報告和狀態同步機制
  - 定期檢查各智能體的執行進度
  - 監控資源使用情況和性能指標
  - 識別潛在的延遲或品質問題
  - 自動更新 Todo List 狀態
  - 智能體執行失敗時的自動重試機制
  - 任務超時的檢測和處理
  - 依賴任務失敗時的連鎖反應處理
  - 備用智能體的自動切換
  
  <questions>
  - 所有可並行的任務是否已同時啟動？
  - 智能體間的溝通是否順暢無阻？
  - 監控系統是否準確反映當前執行狀態？
  - 異常情況是否得到及時識別和處理？
  </questions>
  
  <checks>
    - [ ] 第一批可並行任務已啟動執行
    - [ ] 實時監控機制已建立並運行
    - [ ] 異常處理程序已就緒
    - [ ] Todo List狀態已開始動態更新
    - [ ] 智能體執行進度可見並可追蹤
  </checks>
  </stage>

  <stage id="7: 持續進度監控與動態調整", level_of_think = "think", read_token_budget = "100K", write_token_budget = "50K", cache_read_budget = "50K">
  - 整體項目進度百分比
  - 各子任務的完成狀態
  - 關鍵路徑任務的執行情況
  - 資源使用情況和瓶須分析
  - 品質指標和風險警示
  - 根據實際執行情況調整任務優先級
  - 重新分配資源以應對延遲
  - 啟動備用計畫處理失敗任務
  - 調整並行執行策略以優化整體效率
  - 定期向用戶提供進度報告
  - 及時溝通遇到的問題和解決方案
  - 徵求用戶對變更和調整的確認
  - 提供透明的執行可見性
  
  <questions>
  - 當前的執行進度是否符合預期？
  - 是否有任務出現顯著延遲或品質問題？
  - 資源分配是否需要調整？
  - 用戶是否對當前進度和品質滿意？
  </questions>
  
  <checks>
    - [ ] 監控儀表板已建立並持續更新
    - [ ] 任何延遲或問題已被識別並處理
    - [ ] 必要的調整已實施
    - [ ] 用戶已被告知進度和任何重要變更
    - [ ] 整體執行軌跡保持在可控範圍內
  </checks>
  </stage>

  <stage id="8: 智能結果整合與品質保證", level_of_think = "think harder", read_token_budget = "200K", write_token_budget = "80K", cache_read_budget = "120K">
  - 收集所有子智能體的執行結果
  - 驗證每個子任務的交付品質
  - 檢查結果是否符合原始需求規格
  - 進行整合性測試和一致性檢查
  - 啟動相關的 QA 子智能體進行專業審查
  - 執行跨功能的整合測試
  - 進行用戶接受度測試準備
  - 生成品質報告和改進建議
  - 按照依賴關係順序整合各部分成果
  - 解決整合過程中發現的衝突或不一致
  - 優化整體解決方案的性能和用戶體驗
  - 確保最終成果的完整性和可維護性
  - 準備完整的技術文檔
  - 創建部署和使用指南
  - 提供維護和故障排除指引
  - 生成項目執行總結報告
  
  <questions>
  - 所有子任務的成果是否已成功整合？
  - 整合後的解決方案是否滿足原始需求？
  - 是否還有任何品質或功能缺陷需要解決？
  - 最終交付是否已準備就緒？
  </questions>
  
  <checks>
    - [ ] 所有子任務結果已收集並驗證
    - [ ] QA審查已完成並通過
    - [ ] 整合測試已執行並成功
    - [ ] 完整的技術文檔已準備
    - [ ] 最終解決方案已準備交付
  </checks>
  </stage>

  <stage id="9: 項目總結與持續改進", level_of_think = "think", read_token_budget = "100K", write_token_budget = "60K", cache_read_budget = "40K">
  - 項目整體執行情況分析
  - 各階段的時間和資源使用統計
  - 成功因素和挑戰點的識別
  - 子智能體協調效果評估
  - 記錄最佳實踐和有效的協調模式
  - 識別需要改進的流程和機制
  - 總結子智能體選擇和分配的經驗
  - 提取可複用的任務分解和依賴分析模式
  - 收集用戶對最終成果的反饋
  - 評估解決方案是否完全滿足需求
  - 記錄用戶提出的改進建議
  - 規劃後續的維護和增強計劃
  - 基於本次執行經驗提出協調機制的改進建議
  - 建議新的子智能體類型或能力增強
  - 提出更優的任務分解和依賴分析方法
  - 建議監控和異常處理機制的優化
  
  <questions>
  - 這次多智能體協調執行的整體效果如何？
  - 哪些協調機制運作良好，哪些需要改進？
  - 用戶對最終成果的滿意度如何？
  - 從這次執行中學到了哪些可以應用到未來項目的經驗？
  </questions>
  
  <checks>
    - [ ] 完整的執行總結報告已生成
    - [ ] 關鍵經驗和學習已記錄
    - [ ] 用戶反饋已收集並分析
    - [ ] 改進建議已整理並文檔化
    - [ ] 項目正式結案並移交
  </checks>
  </stage>
</workflow>

<example>
  ## 子任務標準化定義
  為每個子任務創建標準化規格：
  ```
  子任務ID: {唯一標識符}
  任務名稱: {簡潔描述性名稱}
  所需專業領域: {frontend/backend/fullstack/qa/refactor}
  輸入需求: {明確的輸入資料和依賴}
  處理過程: {具體的執行步驟}
  輸出規格: {期望的交付成果格式}
  成功標準: {可量化的完成指標}
  估計時間: {預估執行時間}
  風險等級: {Low/Medium/High}
  ```
</example>

<example>
  ## 子智能體任務分配標準格式
  ```
  智能體調用標準模板：
  
  Task Tool 調用：
  subagent_type: {選定的智能體類型}
  description: "{簡潔的任務描述}"
  prompt: "
  ## 任務概述
  {詳細任務描述}
  
  ## 輸入資料
  {提供的輸入數據和依賴資源}
  
  ## 期望輸出
  {明確的交付標準和格式要求}
  
  ## 成功標準
  {可驗證的完成指標}
  
  ## 特殊要求
  {任何特殊約束或考慮事項}
  ```
</example>

<example>
## 依賴關係類型定義
  ```
  強依賴 (Hard Dependency): 任務B絕對不能在任務A完成前開始
  軟依賴 (Soft Dependency): 任務B最好在任務A完成後開始，但可以並行
  條件依賴 (Conditional Dependency): 根據任務A的結果決定是否執行任務B
  資源依賴 (Resource Dependency): 任務A和B不能同時使用同一資源
  ```
</example>

<exmaple>
## 任務狀態定義
- **pending**: 等待執行的任務
  - **in_progress**: 當前正在執行的任務（每次只能有一個）
  - **completed**: 已完成並驗證的任務  
  - **blocked**: 因依賴未滿足而暫停的任務
  - **failed**: 執行失敗需要處理的任務
</exmaple>